import {
  type Beat,
  type CartItem,
  type InsertBeat,
  type InsertCartItem,
  type InsertOrder,
  type InsertUser,
  type Order,
  type User
} from "@shared/schema";
import { getUserByEmail, getUserById, upsertUser } from './lib/db';

// === Helpers for snake_case <-> camelCase mapping ===
function toDbBeat(beat: any) {
  return {
    ...beat,
    wordpress_id: beat.wordpress_id ?? beat.wordpressId ?? 0,
    image_url: beat.image_url ?? beat.imageUrl ?? '',
    audio_url: beat.audio_url ?? beat.audioUrl ?? '',
    is_active: beat.is_active ?? beat.isActive ?? true,
    created_at: beat.created_at ?? beat.createdAt ?? new Date().toISOString(),
  };
}
function fromDbBeat(row: any) {
  return {
    ...row,
    wordpressId: row.wordpress_id,
    imageUrl: row.image_url,
    audioUrl: row.audio_url,
    isActive: row.is_active,
    createdAt: row.created_at,
  };
}
function toDbUser(user: any) {
  const { stripeCustomerId, ...rest } = user;
  return {
    ...rest,
    stripe_customer_id: user.stripeCustomerId ?? user.stripe_customer_id ?? null,
  };
}
function fromDbUser(row: any) {
  return {
    ...row,
    stripeCustomerId: row.stripe_customer_id,
  };
}
// For Order: ensure items is always an array
function fromDbOrder(row: any) {
  return {
    ...row,
    items: Array.isArray(row.items) ? row.items : [],
  };
}

export interface IStorage {
  // User management
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Beat management
  getBeat(id: number): Promise<Beat | undefined>;
  getBeats(filters?: {
    genre?: string;
    minPrice?: number;
    maxPrice?: number;
    search?: string;
    limit?: number;
    offset?: number;
  }): Promise<Beat[]>;
  createBeat(beat: InsertBeat): Promise<Beat>;
  updateBeat(id: number, beat: Partial<Beat>): Promise<Beat | undefined>;

  // Cart management
  getCartItems(sessionId: string): Promise<CartItem[]>;
  saveCartItems(sessionId: string, items: any): Promise<void>;
  addCartItem(item: InsertCartItem): Promise<CartItem>;
  updateCartItem(id: number, item: Partial<CartItem>): Promise<CartItem | undefined>;
  removeCartItem(id: number): Promise<boolean>;

  // Order management
  getOrder(id: number): Promise<Order | undefined>;
  getOrdersByUser(userId: number): Promise<Order[]>;
  createOrder(order: InsertOrder): Promise<Order>;
  updateOrderStatus(id: number, status: string): Promise<Order | undefined>;

  // Newsletter and contact
  subscribeToNewsletter(email: string): Promise<void>;
  saveContactMessage(message: {
    firstName: string;
    lastName: string;
    email: string;
    subject: string;
    message: string;
  }): Promise<void>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private beats: Map<number, Beat>;
  private cartItems: Map<number, CartItem>;
  private orders: Map<number, Order>;
  private newsletterSubscriptions: Set<string>;
  private contactMessages: any[];
  private currentUserId: number;
  private currentBeatId: number;
  private currentCartId: number;
  private currentOrderId: number;

  constructor() {
    this.users = new Map();
    this.beats = new Map();
    this.cartItems = new Map();
    this.orders = new Map();
    this.newsletterSubscriptions = new Set();
    this.contactMessages = [];
    this.currentUserId = 1;
    this.currentBeatId = 1;
    this.currentCartId = 1;
    this.currentOrderId = 1;

    // Initialize with some sample beats for demonstration
    this.initializeSampleData();
  }

  private initializeSampleData() {
    // Sample beats data matching the design reference
    const sampleBeats = [
      {
        wordpressId: 1,
        title: "Dark Trap Vibes",
        description: "This dark trap beat combines heavy 808s with atmospheric pads and crisp hi-hats.",
        genre: "Trap",
        bpm: 140,
        key: "A minor",
        mood: "Dark",
        price: 2500, // $25.00 in cents
        audioUrl: "https://example.com/audio/dark-trap-vibes.mp3",
        imageUrl: "https://example.com/images/dark-trap-vibes.jpg",
        isActive: true,
      },
      {
        wordpressId: 2,
        title: "Melodic Pop",
        description: "A melodic pop beat perfect for commercial releases and radio play.",
        genre: "Pop",
        bpm: 128,
        key: "C major",
        mood: "Uplifting",
        price: 3000, // $30.00 in cents
        audioUrl: "https://example.com/audio/melodic-pop.mp3",
        imageUrl: "https://example.com/images/melodic-pop.jpg",
        isActive: true,
      },
      {
        wordpressId: 3,
        title: "Hip-Hop Classic",
        description: "Classic hip-hop vibes with boom-bap drums and soulful samples.",
        genre: "Hip-Hop",
        bpm: 95,
        key: "F# minor",
        mood: "Nostalgic",
        price: 3500, // $35.00 in cents
        audioUrl: "https://example.com/audio/hip-hop-classic.mp3",
        imageUrl: "https://example.com/images/hip-hop-classic.jpg",
        isActive: true,
      },
    ];

    sampleBeats.forEach(beat => {
      const id = this.currentBeatId++;
      this.beats.set(id, {
        id,
        ...beat,
        key: beat.key || null,
        description: beat.description || null,
        mood: beat.mood || null,
        audio_url: beat.audioUrl || null,
        image_url: beat.imageUrl || null,
        is_active: beat.isActive ?? true,
        created_at: new Date().toISOString(),
        wordpress_id: (beat as any).wordpress_id ?? (beat as any).wordpressId ?? 0,
      });
    });
  }

  // User management
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.email === email,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.currentUserId++;
    const user: User = { 
      ...insertUser, 
      id, 
      stripeCustomerId: null,
      created_at: new Date().toISOString()
    };
    this.users.set(id, user);
    return user;
  }

  // Beat management
  async getBeat(id: number): Promise<Beat | undefined> {
    return this.beats.get(id);
  }

  async getBeats(filters?: {
    genre?: string;
    minPrice?: number;
    maxPrice?: number;
    search?: string;
    limit?: number;
    offset?: number;
  }): Promise<Beat[]> {
    let beats = Array.from(this.beats.values()).filter(beat => beat.is_active);

    if (filters) {
      if (filters.genre) {
        beats = beats.filter(beat => 
          beat.genre.toLowerCase().includes(filters.genre!.toLowerCase())
        );
      }
      if (filters.search) {
        beats = beats.filter(beat =>
          beat.title.toLowerCase().includes(filters.search!.toLowerCase()) ||
          beat.description?.toLowerCase().includes(filters.search!.toLowerCase())
        );
      }
      if (filters.minPrice) {
        beats = beats.filter(beat => beat.price >= filters.minPrice!);
      }
      if (filters.maxPrice) {
        beats = beats.filter(beat => beat.price <= filters.maxPrice!);
      }
    }

    const offset = filters?.offset || 0;
    const limit = filters?.limit || 50;
    
    return beats.slice(offset, offset + limit);
  }

  async createBeat(insertBeat: InsertBeat): Promise<Beat> {
    const id = this.currentBeatId++;
    const beat: Beat = { 
      ...insertBeat, 
      id,
      key: insertBeat.key || null,
      description: insertBeat.description || null,
      mood: insertBeat.mood || null,
      audio_url: insertBeat.audio_url || null,
      image_url: insertBeat.image_url || null,
      is_active: insertBeat.is_active ?? true,
      created_at: new Date().toISOString()
    };
    this.beats.set(id, beat);
    return beat;
  }

  async updateBeat(id: number, updates: Partial<Beat>): Promise<Beat | undefined> {
    const beat = this.beats.get(id);
    if (beat) {
      const updatedBeat = { ...beat, ...updates };
      this.beats.set(id, updatedBeat);
      return updatedBeat;
    }
    return undefined;
  }

  // Cart management
  async getCartItems(sessionId: string): Promise<CartItem[]> {
    return Array.from(this.cartItems.values()).filter(
      item => item.session_id === sessionId
    );
  }

  async saveCartItems(sessionId: string, items: any): Promise<void> {
    // Clear existing cart items for this session
    for (const [id, item] of Array.from(this.cartItems.entries())) {
      if (item.session_id === sessionId) {
        this.cartItems.delete(id);
      }
    }

    // Add new items
    if (Array.isArray(items)) {
      for (const item of items) {
        await this.addCartItem({
          beat_id: item.beatId,
          license_type: item.licenseType,
          price: item.price,
          quantity: item.quantity,
          session_id: sessionId,
          user_id: item.userId || null,
        });
      }
    }
  }

  async addCartItem(insertItem: InsertCartItem): Promise<CartItem> {
    const id = this.currentCartId++;
    const item: CartItem = { 
      ...insertItem, 
      id,
      quantity: insertItem.quantity || 1,
      session_id: insertItem.session_id || null,
      user_id: insertItem.user_id || null,
      created_at: new Date().toISOString()
    };
    this.cartItems.set(id, item);
    return item;
  }

  async updateCartItem(id: number, updates: Partial<CartItem>): Promise<CartItem | undefined> {
    const item = this.cartItems.get(id);
    if (item) {
      const updatedItem = { ...item, ...updates };
      this.cartItems.set(id, updatedItem);
      return updatedItem;
    }
    return undefined;
  }

  async removeCartItem(id: number): Promise<boolean> {
    return this.cartItems.delete(id);
  }

  // Order management
  async getOrder(id: number): Promise<Order | undefined> {
    return this.orders.get(id);
  }

  async getOrdersByUser(userId: number): Promise<Order[]> {
    return Array.from(this.orders.values()).filter(
      order => order.user_id === userId
    );
  }

  async createOrder(insertOrder: InsertOrder): Promise<Order> {
    const id = this.currentOrderId++;
    const order: Order = { 
      ...insertOrder, 
      id,
      session_id: insertOrder.session_id || null,
      user_id: insertOrder.user_id || null,
      stripe_payment_intent_id: insertOrder.stripe_payment_intent_id || null,
      created_at: new Date().toISOString(),
      email: insertOrder.email,
      status: insertOrder.status,
      total: insertOrder.total,
      items: insertOrder.items ?? [],
    };
    this.orders.set(id, order);
    return order;
  }

  async updateOrderStatus(id: number, status: string): Promise<Order | undefined> {
    const order = this.orders.get(id);
    if (order) {
      const updatedOrder = { ...order, status };
      this.orders.set(id, updatedOrder);
      return updatedOrder;
    }
    return undefined;
  }

  // Newsletter and contact
  async subscribeToNewsletter(email: string): Promise<void> {
    this.newsletterSubscriptions.add(email.toLowerCase());
  }

  async saveContactMessage(message: {
    firstName: string;
    lastName: string;
    email: string;
    subject: string;
    message: string;
  }): Promise<void> {
    this.contactMessages.push({
      ...message,
      timestamp: new Date(),
    });
  }
}

export class DatabaseStorage implements IStorage {
  private orders: Map<number, Order> = new Map();
  // User methods
  async getUser(id: number): Promise<User | undefined> {
    const user = await getUserById(id);
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    // getUserByUsername not implemented in current helpers
    // Would require new helper in lib/db.ts
    return undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const user = await getUserByEmail(email);
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const dbUser = toDbUser(insertUser);
    // Remove camelCase property
    delete dbUser.stripeCustomerId;
    const user = await upsertUser(dbUser);
    return fromDbUser(user);
  }

  // Beat methods - Not implemented (WooCommerce handles beats)
  async getBeat(id: number): Promise<Beat | undefined> {
    // Beats are managed via WooCommerce API, not database
    return undefined;
  }

  async getBeats(filters?: {
    genre?: string;
    minPrice?: number;
    maxPrice?: number;
    search?: string;
    featured?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<Beat[]> {
    // Beats are managed via WooCommerce API, not database
    return [];
  }

  async createBeat(insertBeat: InsertBeat): Promise<Beat> {
    // Beats are managed via WooCommerce API, not database
    throw new Error('Beat creation handled via WooCommerce API');
  }

  async updateBeat(id: number, updates: Partial<Beat>): Promise<Beat | undefined> {
    // Beats are managed via WooCommerce API, not database
    return undefined;
  }

  // Cart methods - Not implemented (client-side cart management)  
  async getCartItems(sessionId: string): Promise<CartItem[]> {
    // Cart is managed client-side with localStorage
    return [];
  }

  async saveCartItems(sessionId: string, items: any): Promise<void> {
    // Cart is managed client-side with localStorage
  }

  async addCartItem(insertItem: InsertCartItem): Promise<CartItem> {
    // Cart is managed client-side with localStorage
    throw new Error('Cart management handled client-side');
  }

  async updateCartItem(id: number, updates: Partial<CartItem>): Promise<CartItem | undefined> {
    // Cart is managed client-side with localStorage
    return undefined;
  }

  async removeCartItem(id: number): Promise<boolean> {
    // Cart is managed client-side with localStorage
    return false;
  }

  // Order methods - Not fully implemented
  async getOrder(id: number): Promise<Order | undefined> {
    const order = this.orders.get(id);
    if (!order) return undefined;
    return {
      ...order,
      items: Array.isArray(order.items) ? order.items : [],
    };
  }

  async getOrdersByUser(userId: number): Promise<Order[]> {
    // Orders not implemented in current helpers
    return [];
  }

  async createOrder(insertOrder: InsertOrder): Promise<Order> {
    // Orders are not directly implemented in current helpers
    // This would require a new helper in lib/db.ts
    throw new Error('Order creation not implemented - requires new helper');
  }

  async updateOrderStatus(id: number, status: string): Promise<Order | undefined> {
    // Orders not implemented in current helpers
    return undefined;
  }

  // Newsletter and contact
  async subscribeToNewsletter(email: string): Promise<void> {
    // Newsletter subscription logic would go here
    // For now, we'll implement a simple log
    console.log(`Newsletter subscription for: ${email}`);
  }

  async saveContactMessage(message: {
    firstName: string;
    lastName: string;
    email: string;
    subject: string;
    message: string;
  }): Promise<void> {
    // Contact message storage logic would go here
    // For now, we'll implement a simple log
    console.log(`Contact message from: ${message.email} - ${message.subject}`);
  }
}

export const storage = new DatabaseStorage();
