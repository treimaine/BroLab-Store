// server/routes/woo.ts
import { Request, Response, Router } from "express";
import { fetchWooCategories, fetchWooProduct, fetchWooProducts } from "../services/woo";
import { handleRouteError } from "../types/routes";
import { WooCommerceMetaData, WooCommerceProduct } from "../types/woocommerce";

const router = Router();

// Helper function to safely convert to string
function safeString(value: unknown): string {
  if (value === null || value === undefined) return "";
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  return "";
}

// Audio URLs extracted from track data
interface TrackUrls {
  previewUrl: string | null; // For playback (30 sec preview)
  downloadUrl: string | null; // For download (full audio)
}

// Helper function to extract both preview and download URLs from track data
function extractAudioUrlsFromTrack(track: Record<string, unknown>): TrackUrls {
  // Preview URL - prioritize audio_preview for playback (30 sec preview generated by Sonaar)
  const audioPreview = safeString(track.audio_preview);

  // Download URL - prioritize track_mp3 for full audio download
  const trackMp3 = safeString(track.track_mp3);
  const src = safeString(track.src);
  const url = safeString(track.url);

  // Full audio URL (for download) - track_mp3 is the original full audio
  const downloadUrl = trackMp3 || src || url || null;

  // Preview URL (for playback) - audio_preview if available, otherwise fallback to full audio
  const previewUrl = audioPreview || downloadUrl;

  return { previewUrl, downloadUrl };
}

// Helper function to extract audio URL from track data (for backward compatibility)
function extractAudioFromTrack(track: Record<string, unknown>): string | null {
  const { previewUrl } = extractAudioUrlsFromTrack(track);
  return previewUrl;
}

// Helper function to parse track data
function parseTrackData(value: unknown): unknown {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch {
      return null;
    }
  }
  return value;
}

// Audio track interface for multi-track products
interface AudioTrack {
  url: string; // Preview URL for playback
  downloadUrl?: string; // Full audio URL for download
  title?: string;
  artist?: string;
  duration?: string;
  mediaId?: number; // WordPress media attachment ID for fetching title
}

// Fetch media title from WordPress REST API
async function fetchMediaTitle(mediaId: number): Promise<string | null> {
  try {
    const wpApiUrl =
      process.env.WORDPRESS_API_URL || "https://brolabentertainment.com/wp-json/wp/v2";
    const response = await fetch(`${wpApiUrl}/media/${mediaId}`);
    if (!response.ok) return null;

    const media = (await response.json()) as { title?: { rendered?: string } };
    return media.title?.rendered || null;
  } catch (error) {
    console.error(`Failed to fetch media ${mediaId}:`, error);
    return null;
  }
}

// Enrich tracks with titles from WordPress media library
async function enrichTracksWithMediaTitles(tracks: AudioTrack[]): Promise<AudioTrack[]> {
  const enrichedTracks = await Promise.all(
    tracks.map(async track => {
      // If track already has a title, keep it
      if (track.title) return track;

      // If track has mediaId, fetch title from WordPress
      if (track.mediaId) {
        const mediaTitle = await fetchMediaTitle(track.mediaId);
        if (mediaTitle) {
          console.log(`üéµ Fetched media title for ID ${track.mediaId}: ${mediaTitle}`);
          return { ...track, title: mediaTitle };
        }
      }

      return track;
    })
  );

  return enrichedTracks;
}

// Title field names used by Sonaar plugin (in priority order)
const TITLE_FIELDS = [
  "title",
  "track_title",
  "stream_title",
  "song_title",
  "name",
  "icecast_title",
] as const;

// Artist field names used by Sonaar plugin (in priority order)
const ARTIST_FIELDS = ["artist", "track_artist", "artist_name"] as const;

// Duration field names used by Sonaar plugin (in priority order)
// Note: "stream_lenght" is a typo in Sonaar plugin, kept for compatibility
const DURATION_FIELDS = [
  "duration",
  "track_duration",
  "stream_lenght",
  "post_audiopreview_duration",
] as const;

// Helper: Extract first non-empty value from track record using field list
function extractFieldValue(
  trackRecord: Record<string, unknown>,
  fields: readonly string[]
): string | undefined {
  for (const field of fields) {
    const value = safeString(trackRecord[field]);
    if (value) return value;
  }
  return undefined;
}

// Helper: Extract track title with media ID consideration
function extractTrackTitle(
  trackRecord: Record<string, unknown>,
  mediaId: number | undefined
): string | undefined {
  // When mediaId exists, let enrichTracksWithMediaTitles fetch the correct title from WordPress API
  // This ensures we use the WordPress media library title instead of potentially incorrect values
  if (mediaId) return undefined;
  return extractFieldValue(trackRecord, TITLE_FIELDS);
}

// Helper: Get valid media ID from track record
function getMediaId(trackRecord: Record<string, unknown>): number | undefined {
  if (!trackRecord.track_mp3_id) return undefined;
  const mediaId = Number(trackRecord.track_mp3_id);
  return Number.isNaN(mediaId) ? undefined : mediaId;
}

// Helper: Build AudioTrack from track record
function buildAudioTrack(trackRecord: Record<string, unknown>): AudioTrack | null {
  const { previewUrl, downloadUrl } = extractAudioUrlsFromTrack(trackRecord);
  if (!previewUrl) return null;

  const mediaId = getMediaId(trackRecord);

  return {
    url: previewUrl,
    downloadUrl: downloadUrl || undefined,
    title: extractTrackTitle(trackRecord, mediaId),
    artist: extractFieldValue(trackRecord, ARTIST_FIELDS),
    duration: extractFieldValue(trackRecord, DURATION_FIELDS),
    mediaId,
  };
}

// Helper: Process array of track data
function processTrackArray(trackData: unknown[], productId: number): AudioTrack[] {
  const tracks: AudioTrack[] = [];

  for (const track of trackData) {
    const trackRecord = track as Record<string, unknown>;
    const audioTrack = buildAudioTrack(trackRecord);

    if (audioTrack) {
      tracks.push(audioTrack);
      console.log(
        `üéµ Product ${productId} - Track:`,
        audioTrack.title || "(no title)",
        `preview: ${audioTrack.url?.substring(0, 50)}...`,
        `download: ${audioTrack.downloadUrl?.substring(0, 50)}...`
      );
    }
  }

  console.log(`üéµ Product ${productId} - Found ${tracks.length} audio tracks`);
  return tracks;
}

// Helper: Process single track object
function processSingleTrackObject(
  trackData: Record<string, unknown>,
  productId: number
): AudioTrack[] {
  const url = extractAudioFromTrack(trackData);
  if (!url) return [];

  const track: AudioTrack = {
    url,
    title: safeString(trackData.title) || undefined,
    artist: safeString(trackData.artist) || undefined,
    duration: safeString(trackData.duration) || undefined,
  };

  console.log(`üéµ Product ${productId} - Found audio URL (object):`, url);
  return [track];
}

// Helper: Get fallback track from audio_url metadata
function getFallbackTrack(
  audioUrlMeta: WooCommerceMetaData | undefined,
  productId: number
): AudioTrack[] {
  if (!audioUrlMeta?.value) return [];

  const audioUrl = safeString(audioUrlMeta.value);
  if (!audioUrl) return [];

  console.log(`üéµ Product ${productId} - Fallback audio URL:`, audioUrl);
  return [{ url: audioUrl }];
}

// Helper function to extract all audio tracks from alb_tracklist metadata
function extractAudioTracks(
  albTracklistMeta: WooCommerceMetaData | undefined,
  audioUrlMeta: WooCommerceMetaData | undefined,
  productId: number
): AudioTrack[] {
  if (!albTracklistMeta?.value) {
    return getFallbackTrack(audioUrlMeta, productId);
  }

  const trackData = parseTrackData(albTracklistMeta.value);

  // Handle array of tracks
  if (Array.isArray(trackData) && trackData.length > 0) {
    return processTrackArray(trackData, productId);
  }

  // Handle single track object
  if (trackData && typeof trackData === "object") {
    const tracks = processSingleTrackObject(trackData as Record<string, unknown>, productId);
    if (tracks.length > 0) return tracks;
  }

  // Fallback to audio_url metadata
  return getFallbackTrack(audioUrlMeta, productId);
}

// Helper function to find metadata value
function findMetaValue(
  metaData: WooCommerceMetaData[] | undefined,
  key: string
): string | number | boolean | null {
  const meta = metaData?.find((m: WooCommerceMetaData) => m.key === key);
  const value = meta?.value ?? null;

  if (Array.isArray(value)) {
    return value.length > 0 ? String(value[0]) : null;
  }
  return value;
}

// Helper function to check if product has tag
function hasTagWithName(tags: unknown[] | undefined, searchTerm: string): boolean {
  return (
    tags?.some(
      (tag: unknown) =>
        tag &&
        typeof tag === "object" &&
        "name" in tag &&
        String((tag as { name: unknown }).name)
          .toLowerCase()
          .includes(searchTerm.toLowerCase())
    ) ?? false
  );
}

// Helper function to map WooCommerce product to beat format
async function mapProductToBeat(product: WooCommerceProduct) {
  const albTracklistMeta = product.meta_data?.find(
    (meta: WooCommerceMetaData) => meta.key === "alb_tracklist"
  );
  const audioUrlMeta = product.meta_data?.find(
    (meta: WooCommerceMetaData) => meta.key === "audio_url"
  );

  const rawTracks = extractAudioTracks(albTracklistMeta, audioUrlMeta, product.id);

  // Enrich tracks with titles from WordPress media library
  const audioTracks = await enrichTracksWithMediaTitles(rawTracks);

  // Preview URL for playback (30 sec preview)
  const audioUrl = audioTracks.length > 0 ? audioTracks[0].url : null;

  // Download URL for full audio (original file)
  const downloadUrl = audioTracks.length > 0 ? audioTracks[0].downloadUrl : null;

  console.log(
    `‚úÖ Product ${product.id} - Final URLs:`,
    `preview: ${audioUrl?.substring(0, 60)}...`,
    `download: ${downloadUrl?.substring(0, 60)}...`,
    `(${audioTracks.length} tracks)`
  );

  return {
    ...product,
    audio_url: audioUrl, // Preview URL for playback
    download_url: downloadUrl, // Full audio URL for download
    audio_tracks: audioTracks, // All tracks for multi-track navigation
    hasVocals:
      findMetaValue(product.meta_data, "has_vocals") === "yes" ||
      hasTagWithName(product.tags, "vocals"),
    stems:
      findMetaValue(product.meta_data, "stems") === "yes" || hasTagWithName(product.tags, "stems"),
    bpm: safeString(findMetaValue(product.meta_data, "bpm")),
    key: safeString(findMetaValue(product.meta_data, "key")),
    mood: safeString(findMetaValue(product.meta_data, "mood")),
    instruments: safeString(findMetaValue(product.meta_data, "instruments")),
    duration: safeString(findMetaValue(product.meta_data, "duration")),
    is_free: product.price === "0" || product.price === "",
  };
}

// Check if WooCommerce is configured
function isWooCommerceConfigured(): boolean {
  return !!(
    process.env.WOOCOMMERCE_API_URL &&
    process.env.VITE_WC_KEY &&
    process.env.WOOCOMMERCE_CONSUMER_SECRET
  );
}

router.get("/products", async (req: Request, res: Response) => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample data");

      const sampleProducts = [
        {
          id: 1,
          name: "Sample Beat 1",
          price: "29.99",
          regular_price: "39.99",
          sale_price: "29.99",
          description: "A sample beat for testing",
          short_description: "Sample beat",
          images: [{ src: "/api/placeholder/300/300" }],
          categories: [{ name: "Hip Hop" }],
          meta_data: [
            { key: "bpm", value: "140" },
            { key: "key", value: "C" },
            { key: "mood", value: "Energetic" },
            { key: "instruments", value: "Drums, Bass, Synth" },
            { key: "duration", value: "3:45" },
            { key: "has_vocals", value: "no" },
            { key: "stems", value: "yes" },
          ],
          tags: [],
          total_sales: 0,
          hasVocals: false,
          stems: true,
          bpm: "140",
          key: "C",
          mood: "Energetic",
          instruments: "Drums, Bass, Synth",
          duration: "3:45",
          is_free: false,
        },
        {
          id: 2,
          name: "Sample Beat 2",
          price: "0",
          regular_price: "0",
          sale_price: "0",
          description: "A free sample beat",
          short_description: "Free beat",
          images: [{ src: "/api/placeholder/300/300" }],
          categories: [{ name: "Trap" }],
          meta_data: [
            { key: "bpm", value: "150" },
            { key: "key", value: "F" },
            { key: "mood", value: "Dark" },
            { key: "instruments", value: "Drums, 808, Hi-hats" },
            { key: "duration", value: "2:30" },
            { key: "has_vocals", value: "yes" },
            { key: "stems", value: "no" },
          ],
          tags: [],
          total_sales: 0,
          hasVocals: true,
          stems: false,
          bpm: "150",
          key: "F",
          mood: "Dark",
          instruments: "Drums, 808, Hi-hats",
          duration: "2:30",
          is_free: true,
        },
      ];

      res.json(sampleProducts);
      return;
    }

    const wooProducts = await fetchWooProducts(req.query);
    const beats = await Promise.all(wooProducts.map(mapProductToBeat));

    res.json(beats);
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch products");
  }
});

router.get("/products/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample product");

      const sampleProduct = {
        id: Number.parseInt(req.params.id, 10),
        name: "Sample Beat",
        price: "29.99",
        regular_price: "39.99",
        sale_price: "29.99",
        description: "A sample beat for testing",
        short_description: "Sample beat",
        images: [{ src: "/api/placeholder/300/300" }],
        categories: [{ name: "Hip Hop" }],
        meta_data: [
          { key: "bpm", value: "140" },
          { key: "key", value: "C" },
          { key: "mood", value: "Energetic" },
          { key: "instruments", value: "Drums, Bass, Synth" },
          { key: "duration", value: "3:45" },
          { key: "has_vocals", value: "no" },
          { key: "stems", value: "yes" },
        ],
        tags: [],
        total_sales: 0,
        hasVocals: false,
        stems: true,
        bpm: "140",
        key: "C",
        mood: "Energetic",
        instruments: "Drums, Bass, Synth",
        duration: "3:45",
        is_free: false,
        audio_url: null,
      };

      res.json({ beat: sampleProduct });
      return;
    }

    const product = await fetchWooProduct(req.params.id);

    if (!product) {
      res.status(404).json({ error: "Product not found" });
      return;
    }

    const beat = await mapProductToBeat(product);
    res.json(beat);
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch product");
  }
});

router.get("/categories", async (_req: Request, res: Response) => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample categories");

      const sampleCategories = [
        { id: 1, name: "Hip Hop", count: 15 },
        { id: 2, name: "Trap", count: 8 },
        { id: 3, name: "R&B", count: 12 },
        { id: 4, name: "Pop", count: 6 },
      ];

      res.json({ categories: sampleCategories });
      return;
    }

    const cats = await fetchWooCategories();
    res.json({ categories: cats });
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch categories");
  }
});

export default router;
