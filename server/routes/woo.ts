// server/routes/woo.ts
import { Request, Response, Router } from "express";
import { fetchWooCategories, fetchWooProduct, fetchWooProducts } from "../services/woo";
import { handleRouteError } from "../types/routes";
import { WooCommerceMetaData, WooCommerceProduct } from "../types/woocommerce";

const router = Router();

// Helper function to safely convert to string
function safeString(value: unknown): string {
  if (value === null || value === undefined) return "";
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  return "";
}

// Audio URLs extracted from track data
interface TrackUrls {
  previewUrl: string | null; // For playback (30 sec preview)
  downloadUrl: string | null; // For download (full audio)
}

// Helper function to extract both preview and download URLs from track data
function extractAudioUrlsFromTrack(track: Record<string, unknown>): TrackUrls {
  // Preview URL - prioritize audio_preview for playback (30 sec preview generated by Sonaar)
  const audioPreview = safeString(track.audio_preview);

  // Download URL - prioritize track_mp3 for full audio download
  const trackMp3 = safeString(track.track_mp3);
  const src = safeString(track.src);
  const url = safeString(track.url);

  // Full audio URL (for download) - track_mp3 is the original full audio
  const downloadUrl = trackMp3 || src || url || null;

  // Preview URL (for playback) - audio_preview if available, otherwise fallback to full audio
  const previewUrl = audioPreview || downloadUrl;

  return { previewUrl, downloadUrl };
}

// Helper function to extract audio URL from track data (for backward compatibility)
function extractAudioFromTrack(track: Record<string, unknown>): string | null {
  const { previewUrl } = extractAudioUrlsFromTrack(track);
  return previewUrl;
}

// Helper function to parse track data
function parseTrackData(value: unknown): unknown {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch {
      return null;
    }
  }
  return value;
}

// Audio track interface for multi-track products
interface AudioTrack {
  url: string; // Preview URL for playback
  downloadUrl?: string; // Full audio URL for download
  title?: string;
  artist?: string;
  duration?: string;
  mediaId?: number; // WordPress media attachment ID for fetching title
}

// Fetch media title from WordPress REST API
async function fetchMediaTitle(mediaId: number): Promise<string | null> {
  try {
    const wpApiUrl =
      process.env.WORDPRESS_API_URL || "https://brolabentertainment.com/wp-json/wp/v2";
    const response = await fetch(`${wpApiUrl}/media/${mediaId}`);
    if (!response.ok) return null;

    const media = (await response.json()) as { title?: { rendered?: string } };
    return media.title?.rendered || null;
  } catch (error) {
    console.error(`Failed to fetch media ${mediaId}:`, error);
    return null;
  }
}

// Enrich tracks with titles from WordPress media library
async function enrichTracksWithMediaTitles(tracks: AudioTrack[]): Promise<AudioTrack[]> {
  const enrichedTracks = await Promise.all(
    tracks.map(async track => {
      // If track already has a title, keep it
      if (track.title) return track;

      // If track has mediaId, fetch title from WordPress
      if (track.mediaId) {
        const mediaTitle = await fetchMediaTitle(track.mediaId);
        if (mediaTitle) {
          console.log(`üéµ Fetched media title for ID ${track.mediaId}: ${mediaTitle}`);
          return { ...track, title: mediaTitle };
        }
      }

      return track;
    })
  );

  return enrichedTracks;
}

// Helper function to extract all audio tracks from alb_tracklist metadata
function extractAudioTracks(
  albTracklistMeta: WooCommerceMetaData | undefined,
  audioUrlMeta: WooCommerceMetaData | undefined,
  productId: number
): AudioTrack[] {
  const tracks: AudioTrack[] = [];

  if (albTracklistMeta?.value) {
    const trackData = parseTrackData(albTracklistMeta.value);

    if (Array.isArray(trackData) && trackData.length > 0) {
      for (const track of trackData) {
        const trackRecord = track as Record<string, unknown>;
        const { previewUrl, downloadUrl } = extractAudioUrlsFromTrack(trackRecord);
        if (previewUrl) {
          // Get media ID for fetching title from WordPress
          const mediaId = trackRecord.track_mp3_id ? Number(trackRecord.track_mp3_id) : undefined;

          // Extract title from various possible field names used by Sonaar
          // IMPORTANT: Only use tracklist title if NO mediaId exists
          // When mediaId exists, let enrichTracksWithMediaTitles fetch the correct title from WordPress API
          // This ensures we use the WordPress media library title (e.g., "Elevate") instead of
          // potentially incorrect values from tracklist fields (e.g., filename-based "Timeless")
          const trackTitle = mediaId
            ? "" // Will be fetched from WordPress media library
            : safeString(trackRecord.title) ||
              safeString(trackRecord.track_title) ||
              safeString(trackRecord.stream_title) ||
              safeString(trackRecord.song_title) ||
              safeString(trackRecord.name) ||
              safeString(trackRecord.icecast_title) ||
              "";

          tracks.push({
            url: previewUrl, // Preview URL for playback
            downloadUrl: downloadUrl || undefined, // Full audio URL for download
            title: trackTitle || undefined,
            artist:
              safeString(trackRecord.artist) ||
              safeString(trackRecord.track_artist) ||
              safeString(trackRecord.artist_name) ||
              undefined,
            duration:
              safeString(trackRecord.duration) ||
              safeString(trackRecord.track_duration) ||
              safeString(trackRecord.stream_lenght) ||
              safeString(trackRecord.post_audiopreview_duration) ||
              undefined,
            mediaId: mediaId && !Number.isNaN(mediaId) ? mediaId : undefined,
          });

          console.log(
            `üéµ Product ${productId} - Track:`,
            trackTitle || "(no title)",
            `preview: ${previewUrl?.substring(0, 50)}...`,
            `download: ${downloadUrl?.substring(0, 50)}...`
          );
        }
      }
      console.log(`üéµ Product ${productId} - Found ${tracks.length} audio tracks`);
    } else if (trackData && typeof trackData === "object") {
      const url = extractAudioFromTrack(trackData as Record<string, unknown>);
      if (url) {
        const trackRecord = trackData as Record<string, unknown>;
        tracks.push({
          url,
          title: safeString(trackRecord.title) || undefined,
          artist: safeString(trackRecord.artist) || undefined,
          duration: safeString(trackRecord.duration) || undefined,
        });
      }
      console.log(`üéµ Product ${productId} - Found audio URL (object):`, url);
    }
  }

  // Fallback to audio_url metadata if no tracks found
  if (tracks.length === 0 && audioUrlMeta?.value) {
    const audioUrl = safeString(audioUrlMeta.value);
    if (audioUrl) {
      tracks.push({ url: audioUrl });
      console.log(`üéµ Product ${productId} - Fallback audio URL:`, audioUrl);
    }
  }

  return tracks;
}

// Helper function to find metadata value
function findMetaValue(
  metaData: WooCommerceMetaData[] | undefined,
  key: string
): string | number | boolean | null {
  const meta = metaData?.find((m: WooCommerceMetaData) => m.key === key);
  const value = meta?.value ?? null;

  if (Array.isArray(value)) {
    return value.length > 0 ? String(value[0]) : null;
  }
  return value;
}

// Helper function to check if product has tag
function hasTagWithName(tags: unknown[] | undefined, searchTerm: string): boolean {
  return (
    tags?.some(
      (tag: unknown) =>
        tag &&
        typeof tag === "object" &&
        "name" in tag &&
        String((tag as { name: unknown }).name)
          .toLowerCase()
          .includes(searchTerm.toLowerCase())
    ) ?? false
  );
}

// Helper function to map WooCommerce product to beat format
async function mapProductToBeat(product: WooCommerceProduct) {
  const albTracklistMeta = product.meta_data?.find(
    (meta: WooCommerceMetaData) => meta.key === "alb_tracklist"
  );
  const audioUrlMeta = product.meta_data?.find(
    (meta: WooCommerceMetaData) => meta.key === "audio_url"
  );

  const rawTracks = extractAudioTracks(albTracklistMeta, audioUrlMeta, product.id);

  // Enrich tracks with titles from WordPress media library
  const audioTracks = await enrichTracksWithMediaTitles(rawTracks);

  // Preview URL for playback (30 sec preview)
  const audioUrl = audioTracks.length > 0 ? audioTracks[0].url : null;

  // Download URL for full audio (original file)
  const downloadUrl = audioTracks.length > 0 ? audioTracks[0].downloadUrl : null;

  console.log(
    `‚úÖ Product ${product.id} - Final URLs:`,
    `preview: ${audioUrl?.substring(0, 60)}...`,
    `download: ${downloadUrl?.substring(0, 60)}...`,
    `(${audioTracks.length} tracks)`
  );

  return {
    ...product,
    audio_url: audioUrl, // Preview URL for playback
    download_url: downloadUrl, // Full audio URL for download
    audio_tracks: audioTracks, // All tracks for multi-track navigation
    hasVocals:
      findMetaValue(product.meta_data, "has_vocals") === "yes" ||
      hasTagWithName(product.tags, "vocals"),
    stems:
      findMetaValue(product.meta_data, "stems") === "yes" || hasTagWithName(product.tags, "stems"),
    bpm: safeString(findMetaValue(product.meta_data, "bpm")),
    key: safeString(findMetaValue(product.meta_data, "key")),
    mood: safeString(findMetaValue(product.meta_data, "mood")),
    instruments: safeString(findMetaValue(product.meta_data, "instruments")),
    duration: safeString(findMetaValue(product.meta_data, "duration")),
    is_free: product.price === "0" || product.price === "",
  };
}

// Check if WooCommerce is configured
function isWooCommerceConfigured(): boolean {
  return !!(
    process.env.WOOCOMMERCE_API_URL &&
    process.env.VITE_WC_KEY &&
    process.env.WOOCOMMERCE_CONSUMER_SECRET
  );
}

router.get("/products", async (req: Request, res: Response) => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample data");

      const sampleProducts = [
        {
          id: 1,
          name: "Sample Beat 1",
          price: "29.99",
          regular_price: "39.99",
          sale_price: "29.99",
          description: "A sample beat for testing",
          short_description: "Sample beat",
          images: [{ src: "/api/placeholder/300/300" }],
          categories: [{ name: "Hip Hop" }],
          meta_data: [
            { key: "bpm", value: "140" },
            { key: "key", value: "C" },
            { key: "mood", value: "Energetic" },
            { key: "instruments", value: "Drums, Bass, Synth" },
            { key: "duration", value: "3:45" },
            { key: "has_vocals", value: "no" },
            { key: "stems", value: "yes" },
          ],
          tags: [],
          total_sales: 0,
          hasVocals: false,
          stems: true,
          bpm: "140",
          key: "C",
          mood: "Energetic",
          instruments: "Drums, Bass, Synth",
          duration: "3:45",
          is_free: false,
        },
        {
          id: 2,
          name: "Sample Beat 2",
          price: "0",
          regular_price: "0",
          sale_price: "0",
          description: "A free sample beat",
          short_description: "Free beat",
          images: [{ src: "/api/placeholder/300/300" }],
          categories: [{ name: "Trap" }],
          meta_data: [
            { key: "bpm", value: "150" },
            { key: "key", value: "F" },
            { key: "mood", value: "Dark" },
            { key: "instruments", value: "Drums, 808, Hi-hats" },
            { key: "duration", value: "2:30" },
            { key: "has_vocals", value: "yes" },
            { key: "stems", value: "no" },
          ],
          tags: [],
          total_sales: 0,
          hasVocals: true,
          stems: false,
          bpm: "150",
          key: "F",
          mood: "Dark",
          instruments: "Drums, 808, Hi-hats",
          duration: "2:30",
          is_free: true,
        },
      ];

      res.json(sampleProducts);
      return;
    }

    const wooProducts = await fetchWooProducts(req.query);
    const beats = await Promise.all(wooProducts.map(mapProductToBeat));

    res.json(beats);
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch products");
  }
});

router.get("/products/:id", async (req: Request, res: Response): Promise<void> => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample product");

      const sampleProduct = {
        id: Number.parseInt(req.params.id, 10),
        name: "Sample Beat",
        price: "29.99",
        regular_price: "39.99",
        sale_price: "29.99",
        description: "A sample beat for testing",
        short_description: "Sample beat",
        images: [{ src: "/api/placeholder/300/300" }],
        categories: [{ name: "Hip Hop" }],
        meta_data: [
          { key: "bpm", value: "140" },
          { key: "key", value: "C" },
          { key: "mood", value: "Energetic" },
          { key: "instruments", value: "Drums, Bass, Synth" },
          { key: "duration", value: "3:45" },
          { key: "has_vocals", value: "no" },
          { key: "stems", value: "yes" },
        ],
        tags: [],
        total_sales: 0,
        hasVocals: false,
        stems: true,
        bpm: "140",
        key: "C",
        mood: "Energetic",
        instruments: "Drums, Bass, Synth",
        duration: "3:45",
        is_free: false,
        audio_url: null,
      };

      res.json({ beat: sampleProduct });
      return;
    }

    const product = await fetchWooProduct(req.params.id);

    if (!product) {
      res.status(404).json({ error: "Product not found" });
      return;
    }

    const beat = await mapProductToBeat(product);
    res.json(beat);
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch product");
  }
});

router.get("/categories", async (_req: Request, res: Response) => {
  try {
    if (!isWooCommerceConfigured()) {
      console.log("‚ö†Ô∏è WooCommerce not configured, returning sample categories");

      const sampleCategories = [
        { id: 1, name: "Hip Hop", count: 15 },
        { id: 2, name: "Trap", count: 8 },
        { id: 3, name: "R&B", count: 12 },
        { id: 4, name: "Pop", count: 6 },
      ];

      res.json({ categories: sampleCategories });
      return;
    }

    const cats = await fetchWooCategories();
    res.json({ categories: cats });
  } catch (error: unknown) {
    handleRouteError(error, res, "Failed to fetch categories");
  }
});

export default router;
