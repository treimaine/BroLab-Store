---
alwaysApply: true
---

# Architecture Technique - Système Paiement Stripe + PayPal

_BroLab Entertainment - Janvier 2025_

**Note** : Le système utilise Stripe et PayPal directement, pas Clerk Billing. Clerk est utilisé uniquement pour l'authentification.

## 1. Architecture Design

```mermaid
graph TD
    A[User Browser] --> B[React Frontend Application]
    B --> C[Clerk SDK - Auth Only]
    B --> D[Stripe Checkout]
    B --> E[PayPal SDK]
    B --> F[Convex SDK]
    F --> G[Convex Database]
    D --> H[Stripe Webhooks]
    E --> I[PayPal Webhooks]
    H --> J[Express Webhook Handler]
    I --> J
    J --> F

    subgraph "Frontend Layer"
        B
    end

    subgraph "Authentication Layer"
        C
    end

    subgraph "Payment Layer"
        D
        E
    end

    subgraph "Data Layer"
        F
    end

    subgraph "Webhook Processing"
        H
        I
        J
    end
```

## 2. Technology Description

- **Frontend**: React@18.3.1 + TypeScript 5.6.3 + Vite 6.3.5 + Tailwind CSS 3.4.17
- **Authentication**: Clerk 5.59.2 (authentification uniquement)
- **Database**: Convex 1.31.2 (19 tables)
- **Webhooks**: Express.js middleware
- **Paiements**: Stripe 18.4.0 + PayPal SDK 1.1.0 (intégration directe)

## 3. Route Definitions

| Route                 | Purpose                                            |
| --------------------- | -------------------------------------------------- |
| /dashboard            | Dashboard utilisateur avec informations abonnement |
| /checkout             | Processus de paiement Stripe/PayPal                |
| /order-confirmation  | Confirmation de commande avec licence               |
| /dashboard/orders     | Historique des commandes et paiements               |
| /dashboard/downloads  | Téléchargements et licences PDF                     |

## 4. API Definitions

### 4.1 Stripe Integration

#### Payment Checkout

```typescript
// Créer une session Stripe Checkout
POST /api/stripe/create-checkout-session
```

Request:
| Param Name | Param Type | isRequired | Description |
|------------|------------|------------|-------------|
| items | array | true | Items du panier avec licences |
| successUrl | string | true | URL de succès |
| cancelUrl | string | true | URL d'annulation |

Response:
| Param Name | Param Type | Description |
|------------|------------|-------------|
| sessionId | string | ID de la session Stripe |
| url | string | URL de redirection Stripe Checkout |

#### PayPal Integration

```typescript
// Créer un paiement PayPal
POST /api/paypal/create-payment
```

Request:
| Param Name | Param Type | isRequired | Description |
|------------|------------|------------|-------------|
| items | array | true | Items du panier |
| returnUrl | string | true | URL de retour |
| cancelUrl | string | true | URL d'annulation |

Response:
| Param Name | Param Type | Description |
|------------|------------|-------------|
| paymentId | string | ID du paiement PayPal |
| approvalUrl | string | URL d'approbation PayPal |

#### Webhook Events

```typescript
// Traitement des webhooks Stripe
POST /api/webhooks/stripe

// Traitement des webhooks PayPal
POST /api/webhooks/paypal
```

Events supportés:

**Stripe:**
- `payment_intent.succeeded`
- `payment_intent.failed`
- `charge.refunded`

**PayPal:**
- `PAYMENT.SALE.COMPLETED`
- `PAYMENT.SALE.DENIED`
- `PAYMENT.SALE.REFUNDED`

### 4.2 Convex Mutations

#### Création de Commande

```typescript
// convex/orders/create.ts
export const createOrder = mutation({
  args: {
    userId: v.optional(v.id("users")),
    clerkUserId: v.optional(v.string()),
    items: v.array(v.any()),
    amount: v.number(),
    currency: v.string(),
    paymentMethod: v.string(),
  },
  handler: async (ctx, args) => {
    // Créer la commande dans Convex
  },
});
```

#### Gestion des Paiements

```typescript
// convex/payments/create.ts
export const createPayment = mutation({
  args: {
    orderId: v.id("orders"),
    provider: v.string(), // 'stripe' | 'paypal'
    status: v.string(),
    amount: v.number(),
    currency: v.string(),
    stripePaymentIntentId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Enregistrer le paiement
  },
});
```

#### Génération de Licence PDF

```typescript
// convex/licenses/create.ts
export const createLicense = mutation({
  args: {
    orderId: v.string(),
    beatId: v.number(),
    licenseType: v.string(),
    buyerEmail: v.string(),
    buyerName: v.string(),
  },
  handler: async (ctx, args) => {
    // Générer la licence PDF
  },
});
```

## 5. Server Architecture Diagram

```mermaid
graph TD
    A[Client Request] --> B[Clerk Authentication]
    B --> C[Route Handler]
    C --> D[Business Logic Layer]
    D --> E[Convex Mutations]
    E --> F[(Convex Database)]

    G[Stripe Webhooks] --> H[Webhook Validator]
    I[PayPal Webhooks] --> H
    H --> J[Event Processor]
    J --> D

    subgraph "Authentication Layer"
        B
    end

    subgraph "Application Layer"
        C
        D
    end

    subgraph "Data Layer"
        E
        F
    end

    subgraph "Event Processing"
        G
        I
        H
        J
    end
```

## 6. Data Model

### 6.1 Data Model Definition

```mermaid
erDiagram
    USERS ||--o{ ORDERS : places
    ORDERS ||--o{ PAYMENTS : has
    ORDERS ||--o{ LICENSES : generates
    USERS ||--o{ DOWNLOADS : performs
    USERS ||--o{ FAVORITES : has

    USERS {
        string clerkId PK
        string email
        string username
        string firstName
        string lastName
        string imageUrl
        string role
        boolean isActive
        number lastLoginAt
        number createdAt
        number updatedAt
    }

    PAYMENTS {
        string id PK
        string orderId FK
        string provider
        string status
        number amount
        string currency
        string stripePaymentIntentId
        string stripeChargeId
        number createdAt
    }

    LICENSES {
        string id PK
        string orderId
        number beatId
        string licenseType
        string licenseNumber
        string buyerEmail
        string pdfUrl
        number purchaseDate
        number createdAt
        number updatedAt
    }
```

### 6.2 Data Definition Language

#### Payments Table

```sql
-- Convex Schema Definition
// convex/schema.ts

payments: defineTable({
  orderId: v.id("orders"), // Référence vers orders
  provider: v.string(), // 'stripe' | 'paypal'
  status: v.string(), // 'succeeded' | 'failed' | 'refunded'
  amount: v.number(), // Montant en centimes
  currency: v.string(), // 'usd', 'eur', etc.
  stripePaymentIntentId: v.optional(v.string()), // ID Stripe Payment Intent
  stripeChargeId: v.optional(v.string()), // ID Stripe Charge
  createdAt: v.number()
})
  .index("by_order", ["orderId"])
  .index("by_pi", ["stripePaymentIntentId"]),
```

#### Licenses Table

```sql
licenses: defineTable({
  orderId: v.string(), // ID commande
  itemId: v.string(), // ID item commande
  beatId: v.number(), // ID beat
  beatTitle: v.string(), // Titre beat
  licenseType: v.string(), // 'basic' | 'premium' | 'unlimited'
  licenseNumber: v.string(), // Numéro licence unique
  buyerEmail: v.string(), // Email acheteur
  buyerName: v.string(), // Nom acheteur
  buyerUserId: v.optional(v.string()), // ID utilisateur Clerk
  price: v.number(), // Prix payé (centimes)
  currency: v.string(), // Devise
  pdfStorageId: v.string(), // ID stockage Convex
  pdfUrl: v.string(), // URL publique PDF
  purchaseDate: v.number(), // Date achat
  createdAt: v.number(),
  updatedAt: v.number()
})
  .index("by_order", ["orderId"])
  .index("by_license_number", ["licenseNumber"])
  .index("by_buyer_email", ["buyerEmail"])
  .index("by_buyer_user_id", ["buyerUserId"])
  .index("by_beat", ["beatId"]),
```

## 7. Webhook Implementation

### 7.1 Stripe Webhook Handler

```typescript
// server/routes/webhooks/stripe.ts
import { Request, Response } from "express";
import Stripe from "stripe";
import { api } from "../../../convex/_generated/api";
import { ConvexHttpClient } from "convex/browser";

const convex = new ConvexHttpClient(process.env.CONVEX_URL!);
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function handleStripeWebhook(req: Request, res: Response) {
  const WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET;

  if (!WEBHOOK_SECRET) {
    throw new Error("STRIPE_WEBHOOK_SECRET is required");
  }

  const sig = req.headers["stripe-signature"] as string;
  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, WEBHOOK_SECRET);
  } catch (err) {
    console.error("Webhook verification failed:", err);
    return res.status(400).json({ error: "Webhook verification failed" });
  }

  try {
    await processStripeEvent(event);
    res.status(200).json({ received: true });
  } catch (error) {
    console.error("Webhook processing failed:", error);
    res.status(500).json({ error: "Webhook processing failed" });
  }
}

async function processStripeEvent(event: Stripe.Event) {
  switch (event.type) {
    case "payment_intent.succeeded":
      await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent);
      break;

    case "payment_intent.payment_failed":
      await handlePaymentFailed(event.data.object as Stripe.PaymentIntent);
      break;

    case "charge.refunded":
      await handleRefund(event.data.object as Stripe.Charge);
      break;

    default:
      console.log(`Unhandled webhook event: ${event.type}`);
  }
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  // Créer le paiement dans Convex
  await convex.mutation(api.payments.create, {
    orderId: paymentIntent.metadata.orderId,
    provider: "stripe",
    status: "succeeded",
    amount: paymentIntent.amount,
    currency: paymentIntent.currency,
    stripePaymentIntentId: paymentIntent.id,
  });

  // Mettre à jour le statut de la commande
  await convex.mutation(api.orders.updateStatus, {
    orderId: paymentIntent.metadata.orderId,
    status: "completed",
  });

  // Générer les licences PDF
  // ...
}
```

### 7.2 PayPal Webhook Handler

```typescript
// server/routes/webhooks/paypal.ts
import { Request, Response } from "express";
import { api } from "../../../convex/_generated/api";
import { ConvexHttpClient } from "convex/browser";

const convex = new ConvexHttpClient(process.env.CONVEX_URL!);

export async function handlePayPalWebhook(req: Request, res: Response) {
  // Validation PayPal webhook
  // ...

  try {
    await processPayPalEvent(req.body);
    res.status(200).json({ received: true });
  } catch (error) {
    console.error("Webhook processing failed:", error);
    res.status(500).json({ error: "Webhook processing failed" });
  }
}

async function processPayPalEvent(event: any) {
  switch (event.event_type) {
    case "PAYMENT.SALE.COMPLETED":
      await handlePaymentSucceeded(event.resource);
      break;

    case "PAYMENT.SALE.DENIED":
      await handlePaymentFailed(event.resource);
      break;

    case "PAYMENT.SALE.REFUNDED":
      await handleRefund(event.resource);
      break;

    default:
      console.log(`Unhandled webhook event: ${event.event_type}`);
  }
}
```

## 8. Frontend Integration

### 8.1 Payment Checkout Component

```typescript
// client/src/components/payments/StripeCheckout.tsx
import { loadStripe } from '@stripe/stripe-js';
import { useMutation } from 'convex/react';
import { api } from '../../../convex/_generated/api';

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY!);

export function StripeCheckout({ items, onSuccess, onError }) {
  const createCheckoutSession = useMutation(api.stripe.createCheckoutSession);

  const handleCheckout = async () => {
    try {
      const session = await createCheckoutSession({
        items,
        successUrl: `${window.location.origin}/order-confirmation`,
        cancelUrl: `${window.location.origin}/checkout`,
      });

      const stripe = await stripePromise;
      await stripe?.redirectToCheckout({ sessionId: session.id });
    } catch (error) {
      onError(error);
    }
  };

  return (
    <Button onClick={handleCheckout}>
      Payer avec Stripe
    </Button>
  );
}
```

### 8.2 License Management Component

```typescript
// client/src/components/licenses/LicensePicker.tsx
export function LicensePicker({ beat, onSelect }) {
  const licenses = [
    { type: 'basic', price: 2999, name: 'Basic License' },
    { type: 'premium', price: 4999, name: 'Premium License' },
    { type: 'unlimited', price: 14999, name: 'Unlimited License' },
  ];

  return (
    <div className="grid grid-cols-3 gap-4">
      {licenses.map((license) => (
        <Card key={license.type}>
          <CardHeader>
            <CardTitle>{license.name}</CardTitle>
            <div className="text-2xl font-bold">
              ${(license.price / 100).toFixed(2)}
            </div>
          </CardHeader>
          <CardContent>
            <Button onClick={() => onSelect(license)}>
              Choisir cette licence
            </Button>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
```

## 9. Security Considerations

### 9.1 Webhook Security

- Vérification signature Stripe avec constructEvent
- Validation signature PayPal
- Validation des données webhook
- Idempotence avec table processedEvents
- Rate limiting sur les endpoints webhook
- Logs détaillés pour audit

### 9.2 Data Protection

- Chiffrement des données sensibles
- Conformité PCI DSS via Stripe (pas de stockage de cartes)
- Anonymisation des logs
- Backup sécurisé des données
- Stockage sécurisé des licences PDF dans Convex File Storage

### 9.3 Access Control

- Vérification des permissions par licence
- Validation côté serveur des téléchargements
- Protection contre les abus
- Monitoring des usages anormaux
- Limitation des téléchargements par licence

## 10. Testing Strategy

### 10.1 Unit Tests

- Tests des mutations Convex (orders, payments, licenses)
- Tests des hooks React (useStripeCheckout, usePayPalPayment)
- Tests des utilitaires de validation

### 10.2 Integration Tests

- Tests des webhooks Stripe
- Tests des webhooks PayPal
- Tests des flux de paiement complets
- Tests de synchronisation des données

### 10.3 E2E Tests

- Parcours complet d'achat (sélection → paiement → licence)
- Tests de génération de licences PDF
- Tests de gestion des téléchargements
- Tests de facturation

Cette architecture assure une intégration robuste et sécurisée du système de paiement Stripe + PayPal avec l'infrastructure existante BroLab.
