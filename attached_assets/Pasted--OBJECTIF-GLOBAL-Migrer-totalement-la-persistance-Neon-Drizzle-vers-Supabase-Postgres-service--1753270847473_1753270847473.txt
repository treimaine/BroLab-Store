ğŸ¯ OBJECTIF GLOBAL
Migrer totalement la persistance Neon/Drizzle vers Supabase (Postgres + service role) :
- Auth custom Express conservÃ©e.
- 100% migrations SQL (pas Drizzle runtime).
- Transactions multiâ€‘tables via fonctions SQL (RPC) si nÃ©cessaire.
- Tests Jest verts Ã  la fin.
- Aucun changement appliquÃ© sans â‰¥95 % de certitude : tu poses des questions, tu proposes, tu attends validation.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§­ PROCESSUS IMPOSÃ‰ (VALIDATION Ã‰TAPE PAR Ã‰TAPE)

### Ã‰TAPE 0 â€” Rappel (dÃ©jÃ  fait)
Cartographie confirmÃ©e. On enchaÃ®ne.

### Ã‰TAPE 1 â€” CONFIG SUPABASE (ENV + CLIENTS)
1. Liste les variables dâ€™env Ã  ajouter (.env.local) :
   - SUPABASE_URL
   - SUPABASE_SERVICE_ROLE_KEY
   - SUPABASE_ANON_KEY (si front SSR/CSR en a besoin)
2. CrÃ©e/complÃ¨te `server/lib/supabaseAdmin.ts` :
   ```ts
   import { createClient } from '@supabase/supabase-js';
   export const supabaseAdmin = createClient(
     process.env.SUPABASE_URL!,
     process.env.SUPABASE_SERVICE_ROLE_KEY!,
     { auth: { persistSession: false } }
   );
(Optionnel) server/lib/supabaseClient.ts pour lâ€™ANON_KEY cÃ´tÃ© front si nÃ©cessaire.

âš ï¸ Ne touche pas encore Ã  server/db.ts ni aux helpers.
â¡ï¸ Propose les diffs (```diff) pour ces fichiers + oÃ¹ placer les env.
STOP, attend ma validation.

Ã‰TAPE 2 â€” REMPLACER Lâ€™INIT DB / SUPPRIMER NEON RUNTIME
Ouvre server/db.ts (ou Ã©quivalent) :

Retire Neon/drizzle runtime.

Exporte soit rien (si inutile), soit de petits utilitaires communs.

Toute requÃªte passera par des helpers dans server/lib/db.ts via supabaseAdmin.

Mets Ã  jour les imports dans les fichiers qui utilisaient db/drizzle.

âš ï¸ Fais-le en petits paquets (3â€“4 fichiers max).
â¡ï¸ Propose un premier diff (server/db.ts + 2 helpers max) â€” STOP, validation.

Ã‰TAPE 3 â€” HELPERS DB (PAR LOTS)
Pour chaque helper (ex : getUserById, upsertUser, upsertSubscription, logDownload, createServiceOrder, etc.) :

Remplacer drizzle/pg par :

ts
Copier
Modifier
const { data, error } = await supabaseAdmin
  .from('<table>')
  .select('*')
  .eq('id', userId)
  .single();
Respecter les types TS (shared/schema.ts).

GÃ©rer les erreurs (throw si error).

ProcÃ¨de par mini-lots :

Lot 1 : users (getUserById, getUserByEmail, upsertUserâ€¦)

Lot 2 : subscriptions

Lot 3 : downloads

Lot 4 : service_orders

etc.

â¡ï¸ Ã€ chaque lot : propose le diff, STOP âœ validation âœ applique âœ npm test.

Ã‰TAPE 4 â€” TRANSACTIONS MULTIâ€‘TABLES (SQL/RPC)
Nous voulons des transactions futures. PrÃ©pare le mÃ©canisme :

CrÃ©er un dossier supabase/sql/ ou supabase/migrations/ (si dÃ©jÃ  utilisÃ©).

Proposer un modÃ¨le de fonction SQL (PL/pgSQL) pour transaction :

sql
Copier
Modifier
create or replace function public.create_service_with_log(
  p_user_id uuid,
  p_service_type text,
  p_details text
)
returns table(id uuid, created_at timestamptz) as $$
declare
  v_order_id uuid;
begin
  -- 1. insert into service_orders
  insert into service_orders(id, user_id, service_type, details)
  values (gen_random_uuid(), p_user_id, p_service_type, p_details)
  returning id, created_at into v_order_id, created_at;
  
  -- 2. insert into activity_log
  insert into activity_log(user_id, action, meta)
  values (p_user_id, 'SERVICE_ORDER_CREATED', jsonb_build_object('service_type', p_service_type));

  return query select v_order_id, created_at;
end; $$ language plpgsql security definer;
On appellera ces fonctions via supabaseAdmin.rpc('create_service_with_log', {...}).

â¡ï¸ Propose 1 fonction RPC dâ€™exemple + oÃ¹ la stocker (SQL file) et comment lâ€™appeler (helper).
STOP âœ validation.
(On appliquera vraiment les fonctions quand on en aura besoin.)

Ã‰TAPE 5 â€” TESTS & MOCKS
Adapter Jest pour mocker @supabase/supabase-js :

Dans jest.setup.ts ou un mock file, crÃ©er un mock createClient qui renvoie un objet avec .from().select/insert/update mockÃ©s.

Mettre Ã  jour les tests existants (remplacer mocks Neon).

VÃ©rifier que tous les tests passent (Lot Aâ†’D dÃ©jÃ  verts).

â¡ï¸ Propose un diff jest.setup.ts + un exemple de mock. STOP âœ validation âœ appliquer âœ npm test.

Ã‰TAPE 6 â€” NETTOYAGE
Supprimer :

DÃ©pendances : @neondatabase/serverless, drizzle-orm (si plus utilisÃ©), pgâ€¦

Fichiers : drizzle.config.ts, migrations drizzle, etc. (si abandon total).

Env Neon (DATABASE_URLâ€¦) si plus besoin.

Mettre Ã  jour package.json, scripts, README/LOCAL_DEV_GUIDE.

â¡ï¸ Propose diff package.json + suppressions. STOP âœ validation âœ appliquer âœ npm install âœ tests.

Ã‰TAPE 7 â€” RÃ‰CAP FINAL
VÃ©rifier npm run dev (serveur OK, env Supabase OK).

Donne un rÃ©sumÃ© :

Fichiers modifiÃ©s/supprimÃ©s

Env Ã  configurer (dev/prÃ©prod/prod)

TODO (RLS, policies, RPC supplÃ©mentaires)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš ï¸ CONTRAINTES

Pas de refactor massif (>50 lignes/fichier) sans mon accord.

Pas de nouvelles deps lourdes sans proposition.

Typescript strict.

Aucun appel rÃ©seau rÃ©el dans les tests (Supabase mockÃ©).

Ne touche pas aux lots validÃ©s (auth, subscriptions, downloads, service orders) au-delÃ  de la migration DB.

âœ… SORTIE ATTENDUE

Diffs clairs, petits, validÃ©s Ã  chaque Ã©tape.

Tests 100 % verts.

Plus de Neon. Supabase fully in place.

Migrations SQL prÃªtes (fichiers .sql).

Helpers et endpoints fonctionnels.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš¦ COMMENCE MAINTENANT
Passe Ã  lâ€™Ã‰TAPE 1 :

Propose les vars env Ã  ajouter + diff server/lib/supabaseAdmin.ts (et supabaseClient.ts si utile).

STOP âœ attends validation.